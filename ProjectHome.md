# What is gwtUtils #
It's planned, to move many usefull things needed in many projects here.

## Features implemented ##
  * AsyncCallbackSimple/-Void/-DoNothing to avoid empty onFailure with some default  behaviors
  * Console (Possible replace for System.out, uses Chroms logging with groups and timemessurement)
  * SchedulerSingle calling it as many times you want, only execute onces
  * AbstractEntryPoint to reduce Boilerblade code for not setting ExceptionHandlers
  * phone/tablet/desktop css class-manager, sets these to the body to create an easy responsive design
  * Special FocusSupport for own Widgets
  * FrontBackPanel panel that can be turned over
  * Serverside support for cache and nocache-Files generated by GWT

## Features planned ##
  * GWTs Logging decrypt clients stacktraces on the Serverside in proc-environments
  * FieldReflection for Entities
  * Cloner to clone Entities
  * Factories/ClassNameResolver
  * Simple Notification System

# Installation #

Maven Support
```
<dependency>
	<groupId>com.googlecode.gwtutils</groupId>
	<artifactId>gwtUtils</artifactId>
	<version>0.0.1</version>
</dependency>
```

Add it to your **.gwt.xml
```
<inherits name="com.googlecode.gwtutils.GwtUtils"/>
```**

# Features #

## AsyncCallbackSimple/-Void/-DoNothing ##
If you have many Default-fallbacks by GWTs uncaughtExceptionHandler, you can use some of this Callback classes to avoid boilerblade onFailure-Codes.
```
new AsyncCallbackSimple<MyReturnClass>() {
	@Override
	public void onSuccess(MyReturnClassresult) {
		// Do something
	}
}
```

## Console ##
Chrome have a nice console-logging-system: https://developers.google.com/chrome-developer-tools/docs/console

If you want to use this via GWT, you can use the the Console-class. It will only work for Chrome, for other Browsers a DoNothing fallback is implemented.

```
Console.INSTANCE.group("myGroup");
Console.INSTANCE.log("myLog");
Console.INSTANCE.endGroup();
```

## SchedulerSingle ##
In many cases you need to do something after all setters are called. To make this easy, you can use the SchedulerSingle. It uses the GWTs Scheduler but will be not scheduled twice at the same time.

```
public class MyWidget extends Composite{
	SchedulerSingle refreshScheduler=new SchedulerSingle(ScheduleType.FINALLY, new ScheduledCommand(){
		public void execute(){
			refresh();
		}
	});
	...
	public void setValue1(...){
		...
		refreshScheduler.schedule();
	}
	
	public void setValue2(...){
		...
		refreshScheduler.schedule();
	}

	public void refresh(...){
		// Update the UI
	}
	

}
```

## AbstractEntryPoint ##
Replace the EntryPoint to the AbstractEntryPoint to reduce Boilerblade code for the special cases for devMode and other ExceptionHandling stuff.

It will also add the Responsive-Design-support.

## Responsive Design ##
When using the AbstractEntryPoint, the support for Responsive Design will be added.

It adds css-classes to the HTML-body dependent to the width of the client:
  * "desktop" (or "not-desktop") (width > 980px)
  * "tablet" (or "not-tablet") (480 > width > 1200px)
  * "phone" (or "not-phone") (width<767px)

You can use this for example in UiBinders with the @external Annotation:
```
@external phone;
.phone .myStyle{
	display:none;
}
```
```
.myStyle{
	width: 100%;
}
@external not-phone;
.not-phone .myStyle{
	width: 50%;
}
```

## Special FocusSupport ##
For some own Widgets its helpful to have a custom Focus-support. This FocusSupport will focus a Widget by clicking on it. It will unfocus when another point on the page (not in the hirarchy of the Widget) will be clicked.

## FrontBackPanel ##
Panel that have a back-side and can be turned over.

## Support for Cache/NoCache Files ##
GWT generates some .cache. and .nocache. files. To tell the Browser how to handle these files, you can use the Guice-Module in the gwtutils. This will add some ServletFilters adding some HTTP-Headers.
```
Guice.createInjector(
  ...
  new ModuleGwtCaching(),
  ...
);
```